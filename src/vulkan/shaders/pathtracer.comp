#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_explicit_arithmetic_types : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_control_flow_attributes : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_vote : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_shuffle : require

#ifdef VALIDATE 
#extension GL_EXT_debug_printf : enable
#endif

// GLSL wants this for uint64_t -> accel struct conversion
#extension GL_EXT_ray_tracing : require

#define SHADER_CONST const
#include "rlpbr_core/device.h"
#undef SHADER_CONST

#include "shader_common.h"
#include "sampler.glsl"
#include "utils.glsl"
#include "inputs.glsl"
#include "math.glsl"

layout (push_constant, scalar) uniform PushConstant {
    RTPushConstant push_const;
};

layout (set = 0, binding = 0, scalar) readonly buffer Instances {
    PackedInstance instances[];
};

layout (set = 0, binding = 1, scalar) readonly buffer MaterialIndices {
    uint32_t instanceMaterials[];
};

layout (set = 0, binding = 2) readonly buffer Lights {
    PackedLight lights[];
};

layout (set = 0, binding = 3) readonly buffer Envs {
    PackedEnv envs[];
};

layout (set = 0, binding = 4) uniform sampler repeatSampler;
layout (set = 0, binding = 5) uniform sampler clampSampler;

layout (set = 0, binding = 6) uniform texture2D msDiffuseAverageTexture; 
layout (set = 0, binding = 7) uniform texture3D msDiffuseDirectionalTexture;
layout (set = 0, binding = 8) uniform texture1D msGGXAverageTexture;
layout (set = 0, binding = 9) uniform texture2D msGGXDirectionalTexture;
layout (set = 0, binding = 10) uniform texture2D msGGXInverseTexture;

layout (set = 0, binding = 11, scalar) writeonly buffer Out {
    uint32_t outputBuffer[];
};

layout (set = 0, binding = 12, scalar) writeonly buffer CurReservoirs {
    Reservoir currentReservoirs[];
};

layout (set = 0, binding = 13, scalar) writeonly buffer PrevReservoirs {
    Reservoir prevReservoirs[];
};

#ifdef AUXILIARY_OUTPUTS

layout (set = 0, binding = 14, scalar) writeonly buffer Normals {
    uint16_t normalBuffer[];
};

layout (set = 0, binding = 15, scalar) writeonly buffer Albedo {
    uint16_t albedoBuffer[];
};

#endif

layout (set = 1, binding = 0) readonly buffer Vertices {
    PackedVertex vertices[];
};

layout (set = 1, binding = 1, scalar) readonly buffer Indices {
    uint32_t indices[];
};

layout (set = 1, binding = 2) uniform texture2D textures[];

layout (set = 1, binding = 3) readonly buffer MatParams {
    PackedMaterial matParams[];
};

layout (set = 1, binding = 4) readonly buffer MeshInfos {
    PackedMeshInfo meshInfos[];
};

// This function needs to be defined before the include of 
// materials.glsl
vec4 fetchSceneTexture(uint32_t idx, vec2 uv, float mip_level)
{
    return textureLod(sampler2D(textures[nonuniformEXT(idx)],
        repeatSampler), uv, mip_level);
}

#include "materials.glsl"
#include "bsdf.glsl"
#include "lighting.glsl"
#include "restir.glsl"

// Debug functions

#define ISTHREAD0 (gl_GlobalInvocationID.x == 0 && \
                   gl_GlobalInvocationID.y == 0 && \
                   gl_GlobalInvocationID.z == 0)

// Unpack functions
Camera unpackCamera(PackedCamera packed)
{
    float aspect = float(RES_X) / float(RES_Y);

    vec4 rot = packed.rotation;
    vec3 view = quatRotate(rot, vec3(0.f, 0.f, 1.f));
    vec3 up = quatRotate(rot, vec3(0.f, 1.f, 0.f));
    vec3 right = quatRotate(rot, vec3(1.f, 0.f, 0.f));

    vec4 pos_fov = packed.posAndTanFOV;

    vec3 origin = pos_fov.xyz;

    float right_scale = aspect * pos_fov.w;
    float up_scale = pos_fov.w;

    return Camera(origin, view, up, right, right_scale, up_scale);
}

void unpackEnv(in uint32_t batch_idx,
               out Camera cam,
               out Camera prev_cam,
               out Environment env)
{
    PackedEnv packed = envs[nonuniformEXT(batch_idx)];
    cam = unpackCamera(packed.cam);
    prev_cam = unpackCamera(packed.prevCam);

    u32vec4 data = packed.data;

    // FIXME: data.x is currently instance offset, change to texture offset
    env.baseTextureOffset = 0;

    env.baseMaterialOffset = data.y;
    env.baseLightOffset = data.z;
    env.numLights = data.w;
    env.tlasAddr = packed.tlasAddr;
}

MeshInfo unpackMeshInfo(uint32_t mesh_idx)
{
    MeshInfo mesh_info;
    mesh_info.indexOffset = meshInfos[nonuniformEXT(mesh_idx)].data.x;

    return mesh_info;
}

Vertex unpackVertex(uint32_t idx)
{
    PackedVertex packed = vertices[nonuniformEXT(idx)];

    vec4 a = packed.data[0];
    vec4 b = packed.data[1];

    u32vec3 packed_normal_tangent = u32vec3(
        floatBitsToUint(a.w), floatBitsToUint(b.x), floatBitsToUint(b.y));

    vec3 normal;
    vec4 tangent_and_sign;
    decodeNormalTangent(packed_normal_tangent, normal, tangent_and_sign);

    Vertex vert;
    vert.position = vec3(a.x, a.y, a.z);
    vert.normal = normal;
    vert.tangentAndSign = tangent_and_sign;
    vert.uv = vec2(b.z, b.w);

    return vert;
}

Triangle fetchTriangle(uint32_t index_offset)
{
    // FIXME: maybe change all this to triangle offset
    u32vec3 indices = u32vec3(
        indices[nonuniformEXT(index_offset)],
        indices[nonuniformEXT(index_offset + 1)],
        indices[nonuniformEXT(index_offset + 2)]);

    return Triangle(
        unpackVertex(indices.x),
        unpackVertex(indices.y),
        unpackVertex(indices.z));
}

uint32_t getMaterialID(uint32_t inst_material_idx)
{
    return instanceMaterials[nonuniformEXT(inst_material_idx)];
}

// Support functions

Vertex interpolateTriangle(Triangle tri, vec2 barys)
{
#define INTERPOLATE_ATTR(tri, attr, barys) \
    (tri.a.attr + barys.x * (tri.b.attr - tri.a.attr) + \
     barys.y * (tri.c.attr - tri.a.attr))

    Vertex interp;

    interp.position = INTERPOLATE_ATTR(tri, position, barys);

    interp.normal = INTERPOLATE_ATTR(tri, normal, barys);

    interp.tangentAndSign = INTERPOLATE_ATTR(tri, tangentAndSign, barys);

    interp.uv = INTERPOLATE_ATTR(tri, uv, barys);

    return interp;

#undef INTERPOLATE_ATTR
}


// Returns *unnormalized vector*
vec3 computeGeometricNormal(Triangle tri)
{
    vec3 v1 = tri.b.position - tri.a.position;
    vec3 v2 = tri.c.position - tri.a.position;

    return cross(v1, v2);
}

TangentFrame computeTangentFrame(Vertex v,
                                 MaterialParams mat_params,
                                 uint32_t base_tex_idx)
{
    vec3 n = v.normal;
    vec3 t = v.tangentAndSign.xyz;

    float bitangent_sign = v.tangentAndSign.w;
    vec3 b = cross(n, t) * bitangent_sign;

    vec3 perturb = vec3(0, 0, 1);
    if (bool(mat_params.flags & MaterialFlagsHasNormalMap)) {
        vec2 xy = textureLod(sampler2D(
            textures[base_tex_idx + TextureConstantsNormalOffset],
            repeatSampler), v.uv, 0.0).xy;

        vec2 centered = xy * 2.0 - 1.0;
        float length2 = clamp(dot(centered, centered), 0.0, 1.0);

        perturb = vec3(centered.x, centered.y, sqrt(1.0 - length2));
    } 

    // Perturb normal
    n = normalize(t * perturb.x + b * perturb.y + n * perturb.z);
    // Ensure perpendicular (if new normal is parallel to old tangent... boom)
    t = normalize(t - n * dot(n, t));
    b = cross(n, t) * bitangent_sign;

    return TangentFrame(t, b, n);
}

TangentFrame tangentFrameToWorld(mat4x3 o2w, mat4x3 w2o, TangentFrame frame,
                                 vec3 ray_dir)
{
    frame.tangent = normalize(transformVector(o2w, frame.tangent));
    frame.bitangent = normalize(transformVector(o2w, frame.bitangent));
    frame.normal = normalize(transformNormal(w2o, frame.normal));
    frame.normal = faceforward(frame.normal, ray_dir, frame.normal);
                                                               
    return frame;                                              
}

bool traceShadeRay(rayQueryEXT ray_query, in uint64_t tlas_addr,
                   in vec3 ray_origin, in vec3 ray_dir,
                   uint32_t visibility_mask)
{
    rayQueryInitializeEXT(ray_query, accelerationStructureEXT(tlas_addr),
                          gl_RayFlagsNoneEXT, visibility_mask,
                          ray_origin, 0.f, ray_dir, LARGE_DISTANCE);

    while (rayQueryProceedEXT(ray_query)) {
        if (rayQueryGetIntersectionTypeEXT(ray_query, false) ==
            gl_RayQueryCandidateIntersectionTriangleEXT) {

            rayQueryConfirmIntersectionEXT(ray_query);
        }
    }

    subgroupBarrier();

    return rayQueryGetIntersectionTypeEXT(ray_query, true) !=
        gl_RayQueryCommittedIntersectionNoneEXT;
}

bool traceShadowRay(in uint64_t tlas_addr, in vec3 ray_origin,
                    in vec3 ray_dir, in float ray_len,
                    in uint32_t visibility_mask)
{
    rayQueryEXT ray_query;
    rayQueryInitializeEXT(ray_query, accelerationStructureEXT(tlas_addr),
                          gl_RayFlagsTerminateOnFirstHitEXT, visibility_mask,
                          ray_origin, 0.f, ray_dir, ray_len);

    while (rayQueryProceedEXT(ray_query)) {
        if (rayQueryGetIntersectionTypeEXT(ray_query, false) ==
            gl_RayQueryCandidateIntersectionTriangleEXT) {

            rayQueryConfirmIntersectionEXT(ray_query);
        }
    }

    subgroupBarrier();

    return rayQueryGetIntersectionTypeEXT(ray_query, true) !=
        gl_RayQueryCommittedIntersectionNoneEXT;
}

void setOutput(uint32_t base_offset, vec3 rgb, uint32_t instance_id)
{
    uint32_t ab = packHalf2x16(rgb.xy);
    uint32_t cd = packHalf2x16(vec2(rgb.z, 0));
    cd |= (instance_id << 16);

    outputBuffer[nonuniformEXT(base_offset)] = ab;
    outputBuffer[nonuniformEXT(base_offset + 1)] = cd;
}

void getHitParams(in rayQueryEXT ray_query, out vec2 barys,
                  out uint32_t tri_idx, out uint32_t material_offset,
                  out uint32_t geo_idx, out uint32_t mesh_offset,
                  out mat4x3 o2w, out mat4x3 w2o)
{
    barys = rayQueryGetIntersectionBarycentricsEXT(ray_query, true);

    tri_idx =
        uint32_t(rayQueryGetIntersectionPrimitiveIndexEXT(ray_query, true));

    material_offset = uint32_t(
        rayQueryGetIntersectionInstanceCustomIndexEXT(ray_query, true));

    geo_idx = 
        uint32_t(rayQueryGetIntersectionGeometryIndexEXT(ray_query, true));

    mesh_offset = uint32_t(
        rayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetEXT(
            ray_query, true));

    o2w = rayQueryGetIntersectionObjectToWorldEXT(ray_query, true);
    w2o = rayQueryGetIntersectionWorldToObjectEXT(ray_query, true);
}

uint32_t getHitInstance(in rayQueryEXT ray_query)
{
    return uint32_t(rayQueryGetIntersectionInstanceIdEXT(ray_query, true));
}

struct HitInfo {
    vec3 position;
    vec3 geoNormal;
    TangentFrame tangentFrame;
    Material material;
};

HitInfo processHit(in rayQueryEXT ray_query, in Environment env,
                   in vec3 ray_dir)
{
    vec2 barys;
    uint32_t tri_idx, material_offset, geo_idx, mesh_offset;
    mat4x3 o2w, w2o;
    getHitParams(ray_query, barys, tri_idx,
                 material_offset, geo_idx, mesh_offset, o2w, w2o);

    MeshInfo mesh_info = unpackMeshInfo(mesh_offset + geo_idx);

    uint32_t index_offset = mesh_info.indexOffset + tri_idx * 3;
    Triangle hit_tri = fetchTriangle(index_offset);
    Vertex interpolated = interpolateTriangle(hit_tri, barys);
    vec3 obj_geo_normal = computeGeometricNormal(hit_tri);

    vec3 world_position =
        transformPosition(o2w, interpolated.position);
    vec3 world_geo_normal =
        transformNormal(w2o, obj_geo_normal);
    world_geo_normal = normalize(world_geo_normal);

    // Unpack materials
    uint32_t material_id = getMaterialID(
        env.baseMaterialOffset + material_offset + geo_idx);

    MaterialParams material_params = unpackMaterialParams(material_id);

    uint32_t base_texture_idx =
        1 + material_id * TextureConstantsTexturesPerMaterial;

    TangentFrame obj_tangent_frame =
        computeTangentFrame(interpolated, material_params,
                            base_texture_idx);

    TangentFrame world_tangent_frame =
        tangentFrameToWorld(o2w, w2o, obj_tangent_frame, ray_dir);

    Material material = processMaterial(material_params,
        base_texture_idx, interpolated.uv, 0);

    return HitInfo(world_position, world_geo_normal,
                   world_tangent_frame, material);
}

bool handleBounce(inout Sampler rng, in HitInfo hit,
                  in vec3 incoming_dir, in vec3 bounce_dir,
                  out vec3 result_origin, out vec3 result_dir)
{
    float alpha_check = samplerGet1D(rng);
    bool pass_through = hit.material.transparencyMask == 0.f ||
        alpha_check > hit.material.transparencyMask;

    result_dir = pass_through ? incoming_dir : bounce_dir;
    
    vec3 bounce_offset_normal =
        dot(result_dir, hit.geoNormal) > 0 ? hit.geoNormal : -hit.geoNormal;
    result_origin = offsetRayOrigin(hit.position, bounce_offset_normal);

    return pass_through;
}

vec3 worldToLocal(vec3 v, TangentFrame frame) 
{
    return vec3(dot(v, frame.tangent), dot(v, frame.bitangent),
        dot(v, frame.normal));
}

vec3 localToWorld(vec3 v, TangentFrame frame)
{
    return v.x * frame.tangent + v.y * frame.bitangent +
        v.z * frame.normal;
}

struct ShadeResult {
    vec3 color;
    vec3 bounceDir;
    vec3 bounceProb;
    uint32_t flags;
};

ShadeResult shade(inout Sampler rng, in Material material,
                  in LightSample light_sample,
                  in vec3 outgoing,
                  in TangentFrame frame)
{
    // These normalizations shouldn't be necessary, but z component
    // needs to be accurate for cos angle
    vec3 wo = normalize(worldToLocal(outgoing, frame));
    vec3 wi = normalize(worldToLocal(light_sample.toLight, frame));

    BSDFParams bsdf = buildBSDF(material, wo);

    vec3 bsdf_response = evalBSDF(bsdf, wo, wi);

    vec3 nee = bsdf_response * light_sample.weight;

    // Compute bounce
    SampleResult bounce = sampleBSDF(rng, bsdf, wo);

    vec3 bounce_dir = localToWorld(bounce.dir, frame);

    ShadeResult result = {
        nee,
        bounce_dir,
        bounce.weight,
        bounce.flags,
    };

    return result;
}

struct PathVertexState {
    vec3 radiance;
    vec3 bounceOrigin;
    vec3 bounceDir;
    vec3 bounceProb;
    uint32_t bounceFlags;
};

PathVertexState processPathVertex(inout Sampler rng, in Environment env,
                                  in HitInfo hit, in vec3 ray_dir)
{
    LightInfo light_info = sampleLights(rng, env,
        hit.position, hit.geoNormal);
    
    ShadeResult shade_result = shade(rng, hit.material,
        light_info.lightSample, -ray_dir, hit.tangentFrame);
    
    PathVertexState result;
    result.radiance = shade_result.color;

    bool pass_through = handleBounce(rng, hit, ray_dir,
                                     shade_result.bounceDir,
                                     result.bounceOrigin,
                                     result.bounceDir);

    result.bounceProb = 
        pass_through ? vec3(1.f - hit.material.transparencyMask) :
            shade_result.bounceProb;
    result.bounceFlags = shade_result.flags;

    bool occluded = traceShadowRay(env.tlasAddr,
                                   light_info.shadowRayOrigin,
                                   light_info.lightSample.toLight,
                                   light_info.shadowRayLength,
                                   1);
    
    // Start setup for next bounce
    if (occluded || pass_through) {
        result.radiance = vec3(0);
    }

    return result;
}

void computeCameraRay(in Camera camera, in u32vec3 idx, inout Sampler rng,
                      out vec3 ray_origin, out vec3 ray_dir)
{
    vec2 jitter = samplerGet2D(rng);
    jitter = vec2(0.f);

    vec2 jittered_raster = vec2(idx.x, idx.y) + jitter;

    vec2 screen = vec2((2.f * jittered_raster.x) / RES_X - 1,
                       (2.f * jittered_raster.y) / RES_Y - 1);

    vec3 right = camera.right * camera.rightScale;
    vec3 up = camera.up * camera.upScale;

    ray_origin = camera.origin;
    ray_dir = normalize(
        right * screen.x + up * screen.y + camera.view);
}

vec2 getScreenSpacePosition(Camera camera, vec3 world_pos)
{
    vec3 to_pos = world_pos - camera.origin;

    vec3 camera_space = vec3(dot(to_pos, camera.right),
                             dot(to_pos, camera.up),
                             dot(to_pos, camera.view));

    return vec2(camera_space.x / camera.rightScale / camera_space.z,
                camera_space.y / camera.upScale / camera_space.z);
}

i32vec2 getPixelCoords(vec2 screen_space)
{
    vec2 offset = (screen_space + 1.f) / 2.f;
    return i32vec2(offset.x * RES_X, offset.y * RES_Y);
}


struct PrimaryResult {
    PathVertexState vertState;
#ifdef AUXILIARY_OUTPUTS
    vec3 auxNormal;
    vec3 auxAlbedo;
#endif
    uint32_t instanceID;
};

PrimaryResult directLighting(in u32vec3 idx, in uint32_t linear_idx,
                             in Camera cam, in Camera prev_cam,
                             in Environment env, inout Sampler rng)
{
    vec3 ray_origin;
    vec3 ray_dir;
    computeCameraRay(cam, idx, rng, ray_origin, ray_dir);

    rayQueryEXT primary_query;
    bool primary_hit = traceShadeRay(primary_query, env.tlasAddr,
                                     ray_origin, ray_dir, 3);

    PrimaryResult result;

    if (!primary_hit) {
        result.vertState.radiance = evalEnvMap(env.baseTextureOffset, ray_dir);
        result.vertState.bounceProb = vec3(0);
        result.instanceID = 0xFFFF;
#ifdef AUXILIARY_OUTPUTS
        result.auxNormal = vec3(0);
        result.auxAlbedo = vec3(0);
#endif
        return result;
    }

    HitInfo hit = processHit(primary_query, env, ray_dir);
    result.instanceID = getHitInstance(primary_query);

#ifdef AUXILIARY_OUTPUTS
    vec3 view_normal = vec3(
        dot(normalize(cam.right), hit.tangentFrame.normal),
        dot(normalize(cam.up) * -1.f, hit.tangentFrame.normal),
        dot(normalize(cam.view) * -1.f, hit.tangentFrame.normal));
    
    view_normal = normalize(view_normal);
    
    vec3 albedo = hit.material.rho;
    
    result.normal = view_normal;
    result.albedo = albedo;
#endif

    vec3 wo = normalize(worldToLocal(-ray_dir, hit.tangentFrame));
    BSDFParams bsdf_params = buildBSDF(hit.material, wo);

    Reservoir cur = initReservoirRIS(bsdf_params, wo, RESERVOIR_M, rng);

    vec2 prev_screen_pos = getScreenSpacePosition(prev_cam, hit.position);
    i32vec2 prev_pixel_coords = getPixelCoords(prev_screen_pos);

    LightInfo light_info = sampleLights(rng, env,
        hit.position, hit.geoNormal);
    
    vec3 wi = normalize(worldToLocal(light_info.lightSample.toLight,
                                     hit.tangentFrame));
    vec3 bsdf_response = evalBSDF(bsdf_params, wo, wi);
    vec3 nee = bsdf_response * light_info.lightSample.weight;

    // Compute bounce
    SampleResult bounce = sampleBSDF(rng, bsdf_params, wo);

    vec3 bounce_dir = localToWorld(bounce.dir, hit.tangentFrame);

    result.vertState.radiance = nee;

    bool pass_through = handleBounce(rng, hit, ray_dir,
                                     bounce_dir,
                                     result.vertState.bounceOrigin,
                                     result.vertState.bounceDir);

    result.vertState.bounceProb = 
        pass_through ? vec3(1.f - hit.material.transparencyMask) :
            bounce.weight;
    result.vertState.bounceFlags = bounce.flags;

    bool occluded = traceShadowRay(env.tlasAddr,
                                   light_info.shadowRayOrigin,
                                   light_info.lightSample.toLight,
                                   light_info.shadowRayLength,
                                   1);
    
    // Start setup for next bounce
    if (occluded || pass_through) {
        result.vertState.radiance = vec3(0);
    }

    return result;
}

vec3 indirectLighting(in Environment env, in vec3 ray_origin, in vec3 ray_dir,
                      in vec3 path_prob, in uint32_t bounce_flags,
                      inout Sampler rng)
{
    vec3 indirect_contrib = vec3(0.f);

    for (int32_t path_depth = 1; path_depth < MAX_DEPTH;
         path_depth++) {

        if (path_prob.x == 0.f && path_prob.y == 0.f &&
            path_prob.z == 0.f) {
            break;
        }

        rayQueryEXT bounce_query;
        bool shade_hit = traceShadeRay(bounce_query, env.tlasAddr,
                                       ray_origin, ray_dir, 3);

        // Miss, hit env map
        if (!shade_hit) {
            if (bool(bounce_flags & BSDFFlagsDelta)) {
                indirect_contrib +=
                    evalEnvMap(env.baseTextureOffset, ray_dir) * path_prob;
            }
            break;
        }

        HitInfo hit = processHit(bounce_query, env, ray_dir);

        PathVertexState bounce_state =
            processPathVertex(rng, env, hit, ray_dir);
        vec3 vert_contrib = path_prob * bounce_state.radiance;
        vert_contrib = min(vert_contrib, vec3(10.f));
#ifdef INDIRECT_CLAMP
        vert_contrib = min(vert_contrib, vec3(INDIRECT_CLAMP));
#endif
        indirect_contrib += vert_contrib;

        ray_origin = bounce_state.bounceOrigin;
        ray_dir = bounce_state.bounceDir;
        path_prob *= bounce_state.bounceProb;
        bounce_flags = bounce_state.bounceFlags;
    }

    return indirect_contrib;
}

// Entry point

layout (local_size_x = LOCAL_WORKGROUP_X,
        local_size_y = LOCAL_WORKGROUP_Y,
        local_size_z = LOCAL_WORKGROUP_Z) in;
void main()
{
    u32vec3 idx = gl_GlobalInvocationID.xyz;

    if (idx.x >= RES_X || idx.y >= RES_Y || idx.z >= BATCH_SIZE) {
        return;
    }

    // Lookup our location within the launch grid
    uint32_t batch_idx = idx.z;

    uint32_t linear_idx = batch_idx * RES_Y * RES_X + idx.y * RES_X + idx.x;
    uint32_t base_out_offset = 2 * linear_idx;

#ifdef AUXILIARY_OUTPUTS
    uint32_t base_aux_offset = 3 * linear_idx;
#endif

    Camera cam, prev_cam;
    Environment env;
    unpackEnv(batch_idx, cam, prev_cam, env);

    vec3 pixel_radiance = vec3(0);
    uint32_t instance_id = 0xFFFF;

#ifdef AUXILIARY_OUTPUTS
    vec3 aux_normal = vec3(0);
    vec3 aux_albedo = vec3(0);
#endif

#ifdef ONE_SAMPLE
    [[dont_unroll]]
#endif
    for (int32_t sample_idx = 0; sample_idx < SPP; sample_idx++) {
        Sampler rng = makeSampler(idx.x, idx.y, sample_idx,
            push_const.baseFrameCounter + batch_idx);

        vec3 sample_radiance;
        vec3 ray_origin;
        vec3 ray_dir;
        vec3 path_prob;
        uint32_t bounce_flags;

        {
            PrimaryResult primary_result =
                directLighting(idx, linear_idx, cam, prev_cam, env, rng);

            sample_radiance = primary_result.vertState.radiance;
            ray_origin = primary_result.vertState.bounceOrigin;
            ray_dir = primary_result.vertState.bounceDir;
            path_prob = primary_result.vertState.bounceProb;
            bounce_flags = primary_result.vertState.bounceFlags;
            instance_id = primary_result.instanceID;

#ifdef AUXILIARY_OUTPUTS
            aux_normal += primary_result.auxNormal / SPP;
            aux_albedo += primary_result.auxAlbedo / SPP;
#endif
        }

        sample_radiance += indirectLighting(env, ray_origin, ray_dir,
                                            path_prob, bounce_flags, rng);

        pixel_radiance += sample_radiance / SPP;
    }

    setOutput(base_out_offset, pixel_radiance, instance_id);

#ifdef AUXILIARY_OUTPUTS
    setAuxiliaries(base_aux_offset, aux_normal, aux_albedo);
#endif
}
