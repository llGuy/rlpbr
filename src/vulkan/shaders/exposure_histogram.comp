#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_explicit_arithmetic_types : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_16bit_storage : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_vote : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_EXT_shader_atomic_float : require

#ifdef VALIDATE
#extension GL_EXT_debug_printf : enable
#endif

#define SHADER_CONST const
#include "rlpbr_core/device.h"
#undef SHADER_CONST

#include "comp_definitions.h"

#define NUM_BINS (128)

layout (set = 0, binding = 0, scalar) buffer TonemapIlluminance {
    float illuminanceBuffer[];
};

shared float histogramBins[NUM_BINS];

float computeBin(float luminance)
{
    float log_luminance = (luminance < MIN_LUMINANCE) ?
        MIN_LOG_LUMINANCE : log2(luminance);

    float remapped = (log_luminance - MIN_LOG_LUMINANCE) * INV_LOG_LUMINANCE_RANGE;
    return remapped * float(NUM_BINS - 1);
}

float inverseBinIdx(int idx)
{
    float remapped = float(idx) / float(NUM_BINS - 1);

    return remapped * LOG_LUMINANCE_RANGE + MIN_LOG_LUMINANCE;
}

// https://knarkowicz.wordpress.com/2016/01/09/automatic-exposure/
layout (local_size_x = LOCAL_WORKGROUP_X,
        local_size_y = LOCAL_WORKGROUP_Y,
        local_size_z = LOCAL_WORKGROUP_Z) in;
void main()
{
    uint32_t batch_idx = gl_GlobalInvocationID.z;
    const u32vec2 xy_idx = gl_LocalInvocationID.xy;

    if (gl_LocalInvocationIndex < NUM_BINS) {
        histogramBins[gl_LocalInvocationIndex] = 0.f;
    }

    const float normalize_factor =
        1.f / float(EXPOSURE_RES_X * EXPOSURE_RES_Y);

    for (int y = 0; y < int(THREAD_ELEMS_Y); y++) {
        for (int x = 0; x < int(THREAD_ELEMS_X); x++) {
            uint32_t y_idx = xy_idx.y * THREAD_ELEMS_Y + y;
            uint32_t x_idx = xy_idx.x * THREAD_ELEMS_X + x;

            bool oob = y_idx >= EXPOSURE_RES_Y || x_idx >= EXPOSURE_RES_X;

            uint32_t idx = batch_idx * EXPOSURE_RES_X * EXPOSURE_RES_Y +
                y_idx * EXPOSURE_RES_X + x_idx;

            float illuminance = oob ? 0 : illuminanceBuffer[idx];

            float bin = computeBin(illuminance);
            int low_bin = clamp(int(bin), 0, NUM_BINS - 1);
            int high_bin = min(low_bin + 1, NUM_BINS - 1);
            float high_weight = fract(bin);

            if (!oob) {
                atomicAdd(histogramBins[low_bin],
                          normalize_factor * (1.f - high_weight));
                atomicAdd(histogramBins[high_bin],
                          normalize_factor * high_weight);
            }
        }
    }

    barrier();

    if (gl_SubgroupID != 0) {
        return;
    }

    const float low_drop_threshold = 0.6;
    const float high_drop_threshold = 0.2;

    // Compute sum. Note that in the current code, this is just equal to
    // the resolution, but may implement center bias later
    float full_sum = 0.0;

    const int bins_per_thread = NUM_BINS / SUBGROUP_SIZE;
    for (int i = 0; i < bins_per_thread; i++) {
        int cur_idx = int(gl_SubgroupInvocationID) + SUBGROUP_SIZE * i;
        float count = histogramBins[cur_idx];

        float cur_sum = subgroupAdd(count);
        full_sum += cur_sum;
    }

    float low_drop = full_sum * low_drop_threshold;
    float remaining_count = full_sum * (1.0 - high_drop_threshold);

    float filtered_log_lum = 0;
    for (int i = 0; i < bins_per_thread; i++) {
        int cur_idx = int(gl_SubgroupInvocationID) + SUBGROUP_SIZE * i;
        float bin_count = histogramBins[cur_idx];

        float prior_count = subgroupExclusiveAdd(bin_count);
        float iter_count = subgroupBroadcast(prior_count + bin_count,
                                             SUBGROUP_SIZE - 1);

        bin_count = max(min(bin_count, remaining_count - prior_count),
                        0.f);

        float low_drop_amount = max(low_drop - prior_count, 0.f);
        
        bin_count = max(bin_count - low_drop_amount, 0.f);

        low_drop -= iter_count;
        remaining_count -= iter_count;

        float bucket_log_lum = inverseBinIdx(cur_idx);

        filtered_log_lum += subgroupAdd(bucket_log_lum * bin_count);
    }

    float filtered_count = 
        full_sum * (1.f - high_drop_threshold - low_drop_threshold);

    if (subgroupElect()) {
        float log_avg = filtered_log_lum / max(filtered_count, 1e-6f);
        log_avg = clamp(log_avg, MIN_LOG_LUMINANCE, MAX_LOG_LUMINANCE);

        float avg_luminance = exp2(log_avg);
        float exposure = 0.18f / (avg_luminance - EXPOSURE_BIAS);

        illuminanceBuffer[batch_idx] = exposure;

        debugPrintfEXT("%f %f %f %f\n", exposure, filtered_count, full_sum,
                       filtered_log_lum / filtered_count);
    }
}
