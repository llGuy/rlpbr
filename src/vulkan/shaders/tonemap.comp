#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_explicit_arithmetic_types : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_16bit_storage : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_vote : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_EXT_shader_atomic_float : require

#ifdef VALIDATE
#extension GL_EXT_debug_printf : enable
#endif

#define SHADER_CONST const
#include "rlpbr_core/device.h"
#undef SHADER_CONST

#include "comp_definitions.h"

layout (set = 0, binding = 0, scalar) buffer TonemapIlluminance {
    float illuminanceBuffer[];
};

layout (set = 0, binding = 1, scalar) buffer Output {
    uint32_t outputBuffer[];
};

vec3 getOutput(uint32_t base_offset, out uint32_t instance_id)
{
    uint32_t ab = outputBuffer[nonuniformEXT(base_offset)];
    uint32_t cd = outputBuffer[nonuniformEXT(base_offset + 1)];

    vec2 rb = unpackHalf2x16(ab);
    vec2 ga = unpackHalf2x16(cd);
    instance_id = cd >> 16;

    return vec3(rb, ga.x);
}

void setOutput(uint32_t base_offset, vec3 rgb, uint32_t instance_id)
{
    uint32_t ab = packHalf2x16(rgb.xy);
    uint32_t cd = packHalf2x16(vec2(rgb.z, 0));
    cd |= instance_id << 16;

    outputBuffer[nonuniformEXT(base_offset)] = ab;
    outputBuffer[nonuniformEXT(base_offset + 1)] = cd;
}

layout (local_size_x = LOCAL_WORKGROUP_X,
        local_size_y = LOCAL_WORKGROUP_Y,
        local_size_z = LOCAL_WORKGROUP_Z) in;
void main()
{
    uint32_t batch_idx = gl_GlobalInvocationID.z;
    u32vec2 xy_idx = gl_GlobalInvocationID.xy;

    if (xy_idx.x >= RES_X || xy_idx.y >= RES_Y) {
        return;
    }

    float exposure = illuminanceBuffer[0];

    uint32_t idx = 2 * (
        batch_idx * RES_Y * RES_X + xy_idx.y * RES_X + xy_idx.x);

    uint32_t instance_id;
    vec3 untonemapped = getOutput(idx, instance_id);

    vec3 exposed = untonemapped * exposure;

    setOutput(idx, exposed, instance_id);
}
